# Test Modeling App

## 概要

UMLクラス図に似た記法でテストアーキテクチャを記述できるアプリケーションです。

## 使い方

### ローカルでの実行

1. リポジトリをクローンします
2. 依存パッケージをインストールするために `npm install` を実行します
3. アプリを起動するには `npm start` を実行します
4. Webブラウザで `http://localhost:3000` にアクセスします

### GitHub Pagesへのデプロイ

mainブランチにプッシュすると、自動的にアプリがデプロイされます。

### 公開中のアプリ

アプリは [https://tyngw.github.io/test-modeling-app/](https://tyngw.github.io/test-modeling-app/) で公開されています。

### アプリの操作方法

#### キーボードショートカット

- `Tab`: 選択中の要素に子要素を追加
- `Delete`: 選択中の要素を削除
- `Enter`: 選択中の要素を編集
- `Esc`: 編集モードを終了
- 編集中に `Tab`: 次のテキストボックスにフォーカス移動
- `Ctrl + Z`: 直前の操作を元に戻す
- `Shift + Ctrl + Z`: 元に戻した操作をやり直す
- `Ctrl + X`: 選択中の要素をカット
- `Ctrl + C`: 選択中の要素をコピー
- `Ctrl + V`: コピーした要素をペースト
- `Ctrl + ←`: 選択中の要素の子を折りたたむ
- `Ctrl + →`: 選択中の要素の子を展開

#### マウス操作

- `クリック`: 要素を選択
- `ダブルクリック`: 要素を編集
  - 要素外をクリックすると編集モードが終了します
- `ドラッグ`: 選択中の要素を移動

#### メニュー操作

- `新規作成`: 新しい図を作成します。未保存の変更は破棄されます。
- `開く`: 保存済みデータを読み込みます。現在のデータは破棄されます。
- `名前を付けて保存`: 図のデータをJSON形式で保存します
- `エクスポート`: 図をSVG形式でエクスポートします

---

### 階層付きクリップボード貼り付け（自動インデント構造復元）

このアプリは、インデント（タブやスペース）で階層化されたテキストをクリップボードから貼り付けると、自動的に階層構造を再現してくれます。

#### 使い方
1. 階層構造を持つテキスト（アウトラインや箇条書きなど）をコピーします
2. アプリ上で貼り付け（`Ctrl + V` または `⌘ + V`）します
3. インデントに基づいて親子関係が自動的に作成されます

#### 例
```
Parent Item
  Child Item 1
    Grandchild Item 1
  Child Item 2
```

#### 結果
- Parent Item
  - Child Item 1
    - Grandchild Item 1
  - Child Item 2

- インデントはタブまたは2つ以上のスペースで認識されます
- タブとスペースの混在も自動判別します
- インデントが不正または深すぎる場合、貼り付けた項目が1つのリストに平坦化されることがあります

---

## 要素の階層構造と表示順序の仕様

このアプリは、要素の階層構造と表示順序を2つの仕組みで管理しています。

### 1. 階層データ構造
- 要素は階層的なツリー構造（`HierarchicalStructure`）で管理されます
- 各親要素は `children` 配列を持ち、子要素の**実際の順序**を保持します
- この構造が要素の順序と関係の**唯一の正解**です

### 2. 表示順序ロジック
- 要素の表示位置はY座標で計算されます
- 階層構造のchildren配列順序が**論理的な順序**を決定します
- 要素の追加や移動時は、まず階層構造に挿入し、その後位置を再計算します

### 3. ドラッグ＆ドロップ時の順序決定

#### betweenモード（要素間ドロップ）
1. **順序計算**: 
   - Y座標順ではなく、階層構造のchildren配列順序を使用
   - `prevElement`と`nextElement`の兄弟要素から挿入位置を計算
   - 論理順序と物理配置の一貫性を保ちます

2. **位置計算**:
   - `insertY`: 表示位置のY座標を計算
   - `insertX`: 親要素や方向継承からX座標を計算
   - `baseOrder`: 階層構造配列の位置で決定

3. **要素挿入**:
   - `moveElementInHierarchy`関数が階層構造への挿入を担当
   - 計算された`baseOrder`位置にchildren配列へ挿入
   - レイアウトを再計算し、表示位置を更新

### 4. 一貫性ルール

- **ADD_ELEMENT / ADD_SIBLING_ELEMENT**: 新要素はchildren配列の末尾に追加、その後位置決定
- **ドラッグ＆ドロップ**: 順序はY座標でなく階層構造で決定
- **コピー＆ペースト**: 複数要素の貼り付けでも階層構造を維持
- **レイアウト計算**: 常にchildren配列順序を尊重

### 5. デバッグと検証
- ブラウザのDevToolsで `state.hierarchicalData` を確認し、実際の順序をチェック
- 表示とデータの順序が一致しているか比較
- 階層が取得できない場合も、`getChildren`関数はID順で一貫したソートを行います

この仕様により、どんな操作でも要素の順序が崩れず、論理階層と表示順序が常に一致します！

---

#### 要素の階層構造と順序管理

要素の階層構造と順序管理は以下の仕様に従います：

##### 階層構造の順序管理
- **階層構造（HierarchicalStructure）のchildren配列順序が唯一の正式な並び順**です
- LocalStorageでの保存時も、この配列順序が維持されます
- 表示時のY座標は、階層構造のchildren配列順序に基づいて計算されます
- orderプロパティは存在せず、純粋に配列のインデックス位置で順序が決まります

##### 要素の追加（ADD_ELEMENT / ADD_SIBLING_ELEMENT）
- 新しい要素は親要素のchildren配列の**末尾**に追加されます
- 画面上では、既存の子要素の下に表示されます
- LocalStorageの階層構造と画面表示順序は常に一致します

##### ドラッグ＆ドロップでの順序変更
- **betweenモード**: 要素を他の要素間にドロップする際、children配列での正確なインデックス位置に挿入されます
  - 前の要素（prevElement）の次の位置、または次の要素（nextElement）の位置に挿入
  - 視覚的な順序と階層構造の配列順序の混同を避け、常にchildren配列順序を基準とします
- **childモード**: 要素を親要素の子として追加する際、children配列の末尾に追加されます
- moveElementInHierarchy関数がchildren配列の操作（splice）により順序を正確に管理します

##### 順序の一貫性
- 階層構造のchildren配列順序が **単一の正確な順序** として扱われます
- すべての操作（追加、移動、コピー&ペースト）でこの順序が維持されます
- Y座標は表示位置の計算値であり、順序決定の基準には使用されません
- getChildrenFromHierarchy関数により、children配列の順序がそのまま保持されて要素リストが返されます

---

## ライセンス

このプロジェクトはMITライセンスで公開されています。詳細は [LICENSE](./LICENSE) をご覧ください。

---

もし分かりにくい箇所や追加で知りたいことがあれば、どんどん質問してくださいね！一緒に楽しく学んでいきましょう！
